/* Given a list of coordinates and a set of layer images, gather tiles from
   the same coordinates across all layers and merge them into a single image.

   ./collect_tile_layers {output.png} {points.txt} {input.png...}

   This is useful for checking the consistency of breakable/collectible
   tile images, without having to scroll through all output images.
*/

#include<png.h>
#include<stdio.h>
#include<stdlib.h>
#include<string.h>

/* Number of pixels in each tile. */
#define TILE_SIZE  32

/* Width of each bitmap character.  See generate_font.pl. */
#define CHAR_WIDTH  16

/* Number of pixels reserved for labels.  The longest label is
   "9999,9999", so we only need 9 characters worth plus a bit of spacing. */
#define LABEL_MARGIN  (CHAR_WIDTH * 9 + 16)

/* Font data, generated by generate_font.pl.
   Each array element contains a grayscale pixel. */
extern unsigned char font[11][TILE_SIZE][CHAR_WIDTH];

/* Input coordinate. */
typedef struct { int x, y; } XY;

/* Copy pixels from input file to output.  Returns 0 on success. */
static int GatherTilesFromLayer(int index,
                                png_image *output_image,
                                png_bytep output_pixels,
                                const XY *points,
                                int point_count,
                                const char *input_file)
{
   const int output_stride = output_image->width * 4;
   int i, y, input_stride;
   png_image input_image;
   png_bytep input_pixels;

   /* Load input pixels. */
   memset(&input_image, 0, sizeof(input_image));
   input_image.version = PNG_IMAGE_VERSION;
   if( !png_image_begin_read_from_file(&input_image, input_file) )
      return printf("%s: open error\n", input_file);
   input_image.format = PNG_FORMAT_RGBA;
   input_pixels = (png_bytep)malloc(PNG_IMAGE_SIZE(input_image));
   if( input_pixels == NULL )
   {
      return printf("%s: not enough memory for %d * %d pixels\n", input_file,
                    (int)input_image.width, (int)input_image.height);
   }
   if( !png_image_finish_read(&input_image, NULL, input_pixels, 0, NULL) )
   {
      free(input_pixels);
      return printf("%s: read error\n", input_file);
   }

   /* Copy tiles. */
   input_stride = input_image.width * 4;
   for(i = 0; i < point_count; i++)
   {
      if( points[i].x + TILE_SIZE > (int)input_image.width ||
          points[i].y + TILE_SIZE > (int)input_image.height )
      {
         free(input_pixels);
         return printf("%s: tile at (%d,%d) is out of bounds\n",
                       input_file, points[i].x, points[i].y);
      }
      for(y = 0; y < TILE_SIZE; y++)
      {
         memcpy(output_pixels +
                   (i * TILE_SIZE + y) * output_stride +
                   index * TILE_SIZE * 4 +
                   LABEL_MARGIN * 4,
                input_pixels +
                   (points[i].y + y) * input_stride +
                   points[i].x * 4,
                TILE_SIZE * 4);
      }
   }

   /* Success. */
   free(input_pixels);
   return 0;
}

/* Fill label area with opaque black. */
static void InitLabelArea(png_image *output_image, png_bytep output_pixels)
{
   const int stride = output_image->width * 4;
   int x, y;

   for(y = 0; y < (int)output_image->height; y++)
   {
      for(x = 0; x < LABEL_MARGIN; x++)
      {
         output_pixels[y * stride + x * 4] = 0;
         output_pixels[y * stride + x * 4 + 1] = 0;
         output_pixels[y * stride + x * 4 + 2] = 0;
         output_pixels[y * stride + x * 4 + 3] = 0xff;
      }
   }
}

/* Draw a single coordinate label at (0,output_y).

   We could have done this separately with a script that calls ImageMagick,
   but it's much faster to have this tool do it.                            */
static void DrawCoordinate(png_image *output_image,
                           png_bytep output_pixels,
                           int output_y,
                           const XY *point)
{
   const int stride = output_image->width * 4;
   char text[16];
   int i, o, c, x, y;

   /* Longest label is "9999,9999", and the range is enforced in main(),
      so here we can get away with using sprintf without bounds check.   */
   sprintf(text, "%4d,%4d", point->x, point->y);

   /* Rasterize each character. */
   for(i = 0; text[i] != '\0'; i++)
   {
      if( text[i] == ' ' )
         continue;
      c = text[i] == ',' ? 10 : text[i] - '0';
      for(y = 0; y < TILE_SIZE; y++)
      {
         for(x = 0; x < CHAR_WIDTH; x++)
         {
            o = (output_y + y) * stride + (i * CHAR_WIDTH + x) * 4;
            output_pixels[o] =
            output_pixels[o + 1] =
            output_pixels[o + 2] = font[c][y][x];
         }
      }
   }
}

int main(int argc, char **argv)
{
   int point_count = 0, buffer_size = 0, i;
   XY *points = NULL;
   FILE *f;
   png_image image;
   png_bytep pixels;

   if( argc < 4 )
      return printf("%s {output.png} {points.txt} {input.png...}\n", *argv);

   /* Load input points. */
   if( (f = fopen(argv[2], "r")) == NULL )
   {
      printf("%s: read error\n", argv[2]);
      return 1;
   }
   for(;;)
   {
      if( point_count + 1 > buffer_size )
      {
         buffer_size = (buffer_size == 0 ? 4 : buffer_size * 2);
         if( (points = (XY*)realloc(points, buffer_size * sizeof(XY))) == NULL )
         {
            fclose(f);
            return puts("Out of memory");
         }
      }
      if( fscanf(f, "%d,%d", &points[point_count].x, &points[point_count].y)
            != 2 )
      {
         break;
      }
      if( points[point_count].x < 0 || points[point_count].y < 0 ||
          points[point_count].x > 9999 || points[point_count].y > 9999 )
      {
         printf("%s: invalid coordinate: %d,%d\n",
                argv[2], points[point_count].x, points[point_count].y);
         free(points);
         return 1;
      }
      point_count++;
   }
   fclose(f);
   if( point_count == 0 )
      return printf("%s: no points\n", argv[2]);

   /* Allocate output. */
   memset(&image, 0, sizeof(image));
   image.version = PNG_IMAGE_VERSION;
   image.format = PNG_FORMAT_RGBA;
   image.width = TILE_SIZE * (argc - 3) + LABEL_MARGIN;
   image.height = TILE_SIZE * point_count;
   pixels = (png_bytep)malloc(PNG_IMAGE_SIZE(image));
   if( pixels == NULL )
   {
      printf("Not enough memory for %d * %d pixels\n",
             (int)image.width, (int)image.height);
      free(points);
      return 1;
   }

   /* Copy pixels. */
   for(i = 0; i < argc - 3; i++)
   {
      if( GatherTilesFromLayer(i, &image, pixels, points, point_count,
                               argv[i + 3]) != 0 )
      {
         free(pixels);
         free(points);
         return 1;
      }
   }

   /* Add labels. */
   InitLabelArea(&image, pixels);
   for(i = 0; i < point_count; i++)
      DrawCoordinate(&image, pixels, i * TILE_SIZE, &points[i]);

   /* Write output.  Note that we optimized for encoding speed rather than
      output size.  This is fine since output is only used for debugging.  */
   image.flags |= PNG_IMAGE_FLAG_FAST;
   if( !png_image_write_to_file(&image, argv[1], 0, pixels, 0, NULL) )
   {
      free(pixels);
      free(points);
      return printf("%s: write error\n", argv[1]);
   }

   /* Cleanup. */
   free(pixels);
   free(points);
   return 0;
}
