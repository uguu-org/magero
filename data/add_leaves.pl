#!/usr/bin/perl -w
# Add extra leaf elements to SVG according to a placement region map.
#
# ./add_leaves.pl {leaves.svg} {in.svg} {regions.pgm} {mul} {frame} > {out.svg}
#
#   leaves.svg = Leaves template.  Must contain only paths with exactly two
#                curves each, and no transform attribute on any element.
#
#   input.svg = Source image where leaves will be added.  Must contain a layer
#               matching name generated by leaves_layer_name().
#
#   regions.pgm = 8bit grayscale bitmap with white pixels indicating where
#                 leaves will be added.
#
#   mul = scaling factor.  1 = original size, 0.5 = half size.
#
#   frame = Frame number from 0 to 3.
#
# We have this script for adding leaves instead of just have all the leaves
# baked into world_master.svg.  This makes editing easier because we only
# need to adjust the shape of the leaf region in world_master.svg, instead
# of having to tweak individual leaves to make things consistent.  More
# importantly, it reduced the size of the layers to a point that is acceptable
# by libxml.  If we just bake all the leaves in, select_layers.pl will fail
# with an error that looks like this:
#
#  :426268: parser error : internal error: Huge input lookup

use strict;
use XML::LibXML;

use constant WIDTH => 9600;
use constant HEIGHT => 6400;
use constant OUTPUT_LAYER => "IBG common";

# Load leaves region map as a single string, one byte per pixel.
sub load_region_map($)
{
   my ($filename) = @_;
   open my $handle, "<$filename" or die $!;
   my $data = join "", <$handle>;
   close $handle;

   my $header = "P5\n" . WIDTH . " " . HEIGHT . "\n255\n";
   if( substr($data, 0, length($header)) ne $header )
   {
      die "Unexpected image format, expected header:\n$header\n";
   }
   my $expected_size = length($header) + WIDTH * HEIGHT;
   if( length($data) != $expected_size )
   {
      die "Unexpected image size, expected $expected_size, got " .
          length($data) . "\n";
   }
   return substr($data, length($header));
}

# Check if a pixel is within designated leaf region.
sub within_leaf_region($$$)
{
   my ($region_map, $x, $y) = @_;

   $x = int($x);
   $y = int($y);
   if( $x < 0 || $x >= WIDTH || $y < 0 || $y >= HEIGHT )
   {
      return 0;
   }
   return ord(substr($region_map, $y * WIDTH + $x, 1));
}

# Find layer where leaves are to be added.
sub find_layer_by_name($$)
{
   my ($dom, $name) = @_;

   foreach my $group ($dom->getElementsByTagName("g"))
   {
      if( defined($group->{"inkscape:label"}) &&
          $group->{"inkscape:label"} eq $name )
      {
         return $group;
      }
   }
   die "Layer not found: $name\n";
}

# Get width and height of SVG.
sub get_svg_size($)
{
   my ($dom) = @_;

   foreach my $svg ($dom->getElementsByTagName("svg"))
   {
      if( defined($svg->{"width"}) && defined($svg->{"height"}) )
      {
         return $svg->{"width"}, $svg->{"height"};
      }
   }
   die "Can not get SVG dimension\n";
}

# Convert leaf path to use only relative coordinates.
#
# We only support paths containing curves, and only those with "c" commands
# as opposed to "s" commands.
# https://www.w3.org/TR/SVG2/paths.html#PathDataCubicBezierCommands
#
# This is exactly unlike what we did in explode_debris.pl, which only
# supported straight lines.  One of these days I might merge the two and
# make a single generalized SVG path handling library.  It hasn't happened
# yet because every time I write one of these scripts, I tell myself that I
# probably won't need another custom tool.
sub canonicalize_curves($$)
{
   my ($scale, $d) = @_;

   my $number = '(-?\d+(?:\.\d*)?)';
   my $space = '[, ]+';
   my $point = ($space . $number) x 2;

   # Move to start of curve.
   my $move = qr{^[Mm]${point}(.*)$};
   unless( $d =~ $move )
   {
      die "Unexpected path data: $d\n";
   }
   my ($mx, $my) = ($1 * $scale, $2 * $scale);
   my $remainder = $3;

   # Canonized path string.
   my $path = "m $mx,$my c";

   # Current cursor location.
   my ($cx, $cy) = ($mx, $my);

   # Current command;
   my $cmd = undef;

   # Convert curve elements until nothing remains.
   my $curve_with_cmd = qr{^\s*([Cc])${point}${point}${point}(.*)$};
   my $continue_curve = qr{^${point}${point}${point}(.*)$};
   my $closepath = qr{^\s*[Zz]\s*$};
   while( $remainder !~ $closepath )
   {
      my ($c, $x1, $y1, $x2, $y2, $x3, $y3);
      if( $remainder =~ $curve_with_cmd )
      {
         ($c, $x1, $y1, $x2, $y2, $x3, $y3) = ($1, $2, $3, $4, $5, $6, $7);
         $remainder = $8;
      }
      elsif( $remainder =~ $continue_curve )
      {
         unless( defined($cmd) )
         {
            die "Unexpected path data: $d\n";
         }
         $c = $cmd;
         ($x1, $y1, $x2, $y2, $x3, $y3) = ($1, $2, $3, $4, $5, $6);
         $remainder = $7;
      }
      else
      {
         die "Unexpected path data: $d\n";
      }

      # Scale coordinates.
      $x1 *= $scale; $y1 *= $scale;
      $x2 *= $scale; $y2 *= $scale;
      $x3 *= $scale; $y3 *= $scale;

      # Convert absolute coordinates to relative.
      if( $c eq 'C' )
      {
         $x1 -= $cx; $y1 -= $cy;
         $x2 -= $cx; $y2 -= $cy;
         $x3 -= $cx; $y3 -= $cy;
      }

      # Append to canonicalized path.
      $path .= " $x1,$y1 $x2,$y2 $x3,$y3";

      $cmd = $c;
      $cx += $x3;
      $cy += $y3;
   }

   $path .= " z";
   return $path;
}

# Regular expression for parsing a canonicalized leaf path.
my $leaf_path_pattern = qr{^m
                           \s+([^,\s]+),([^,\s]+)
                           \s+c
                           \s+([^,\s]+),([^,\s]+)
                           \s+([^,\s]+),([^,\s]+)
                           \s+([^,\s]+),([^,\s]+)
                           \s+([^,\s]+),([^,\s]+)
                           \s+([^,\s]+),([^,\s]+)
                           \s+([^,\s]+),([^,\s]+)}x;

# Extract path coordinates from canonicalized leaf path.
sub parse_leaf_path($)
{
   my ($path) = @_;

   $path =~ $leaf_path_pattern or die;
   return $1, $2,
          $3, $4,   $5,  $6,   $7, $8,
          $9, $10,  $11, $12,  $13, $14;
}

# Rotate path control points such that node with lower Y-value is listed first.
sub fix_orientation($)
{
   my ($path) = @_;

   my ($mx, $my,
       $d1x1, $d1y1,
       $d1x2, $d1y2,
       $d1x3, $d1y3,
       $d2x1, $d2y1,
       $d2x2, $d2y2,
       $d2x3, $d2y3) = parse_leaf_path($path);

   if( $d1y3 >= 0 )
   {
      return $path;
   }

   # Before:
   #  mx -> d1x1 -> d1x2 -> d1x3
   #                          |
   #                          v
   #        d2x3 <- d2x2 <- d2x1
   #
   # After:
   #  d1x3 -> d2x1 -> d2x2 -> d2x3
   #                            |
   #                            v
   #          d1x3 <- d1x2 <- d1x1
   $mx += $d1x3;
   $my += $d1y3;

   ($d1x1, $d1x2, $d1x3, $d2x1, $d2x2, $d2x3) =
   ($d2x1, $d2x2, $d2x3, $d1x1, $d1x2, $d1x3);

   ($d1y1, $d1y2, $d1y3, $d2y1, $d2y2, $d2y3) =
   ($d2y1, $d2y2, $d2y3, $d1y1, $d1y2, $d1y3);

   return "m $mx,$my c" .
          " $d1x1,$d1y1" .
          " $d1x2,$d1y2" .
          " $d1x3,$d1y3" .
          " $d2x1,$d2y1" .
          " $d2x2,$d2y2" .
          " $d2x3,$d2y3 z";
}

# Get coordinate of the two pointy ends of the leaf path within each tile.
sub get_leaf_size($)
{
   my ($path) = @_;

   # We could rewrite this using parse_leaf_path instead, but using a more
   # specific regular expression here saves ~1 second of build time.
   $path =~ /^m ([^,\s]+),([^,\s]+) c \S+ \S+ ([^,\s]+),([^,\s]+) .*$/ or die;
   my ($x0, $y0, $dx, $dy) = ($1, $2, $3, $4);
   return $x0, $y0, $x0 + $dx, $y0 + $dy;
}

# Translate a canonicalized path.
sub translate_path($$$)
{
   my ($path, $dx, $dy) = @_;

   $path =~ /^m ([^,]+),([^,]+) (c.*)$/ or die;
   my $mx = $1 + $dx;
   my $my = $2 + $dy;
   return "m $mx,$my $3";
}

# Find all leave elements and canonicalize all paths.
sub collect_leaves_from_template($$)
{
   my ($template_dom, $scale) = @_;
   my @leaves = ();

   foreach my $node ($template_dom->getElementsByTagName("path"))
   {
      if( defined($node->{"transform"}) && $node->{"transform"} ne "" )
      {
         die "Path contains nonempty transforms\n";
      }
      if( defined($node->{"d"}) )
      {
         $node->{"d"} =
            fix_orientation(canonicalize_curves($scale, $node->{"d"}));
         push @leaves, $node;
      }
      else
      {
         die "Path is missing 'd' attribute\n";
      }
   }

   return @leaves;
}

# Determine animation frame index for a single leaf.
sub get_leaf_animation_frame($$$$$$$)
{
   my ($frame, $tile_size_x, $tile_size_y, $x1, $y1, $x2, $y2) = @_;

   # Never animate a leaf if it cuts across a tile boundary.
   if( $x1 < 0 || $x1 >= $tile_size_x || $y1 < 0 || $y1 >= $tile_size_y ||
       $x2 < 0 || $x2 >= $tile_size_x || $y2 < 0 || $y2 >= $tile_size_y )
   {
      return 0;
   }

   # Generate an arbitrary hash value based on positions within a tile.
   #
   # Magic constants from here: https://thebookofshaders.com/10/
   my $hash = abs(int(sin($x1 * 12.9898 + $y1 * 78.233) * 43758.5453123));

   # Disable animation for some random subset of leaves.  This is so that
   # not all the frozen leaves fall on tile boundaries.
   if( ($hash & 0xf0) == 0 )
   {
      return 0;
   }
   return ($hash + $frame) & 3;
}

# Adjust a single path to add swaying motion.
sub animate_path($$$)
{
   my ($path, $scale, $frame) = @_;

   if( $frame == 0 )
   {
      return $path;
   }

   # Leave animation has 4 frames, but actually frame 3 is the same as frame 1,
   # so it's a sort of ping-pong animation (i.e. 0-1-2-1-0).  We do this to
   # reduce the number of tile variations.
   if( $frame > 2 )
   {
      $frame = 1;
   }

   my ($mx, $my,
       $d1x1, $d1y1,
       $d1x2, $d1y2,
       $d1x3, $d1y3,
       $d2x1, $d2y1,
       $d2x2, $d2y2,
       $d2x3, $d2y3) = parse_leaf_path($path);

   # Set direction vector to be perpendicular to the line that goes through
   # the two leave vertices.
   my $dx = $d2y3;
   my $dy = -$d2x3;

   # Make direction vector point downward, and make it a unit vector.
   if( $dy < 0 )
   {
      $dx = -$dx;
      $dy = -$dy;
   }
   my $s = sqrt($dx * $dx + $dy * $dy);
   $dx /= $s;
   $dy /= $s;

   # Scale direction vector to match the scaling done to the path points.
   $dx *= $scale;
   $dy *= $scale;

   # Apply direction vector to control points.
   $d1x1 += $dx * $frame;
   $d1y1 += $dy * $frame;
   $d1x2 += $dx * $frame * 1.5;
   $d1y2 += $dy * $frame * 1.5;
   $d1x3 += $dx * $frame * 2;
   $d1y3 += $dy * $frame * 2;

   $d2x1 -= $dx * $frame;
   $d2y1 -= $dy * $frame;
   $d2x2 -= $dx * $frame * 1.5;
   $d2y2 -= $dy * $frame * 1.5;
   $d2x3 -= $dx * $frame * 2;
   $d2y3 -= $dy * $frame * 2;

   return "m $mx,$my c " .
          " $d1x1,$d1y1" .
          " $d1x2,$d1y2" .
          " $d1x3,$d1y3" .
          " $d2x1,$d2y1" .
          " $d2x2,$d2y2" .
          " $d2x3,$d2y3 z";
}

# Add path to layer.
sub add_path($$$$$)
{
   my ($parent, $path, $style, $dx, $dy) = @_;

   my $element = XML::LibXML::Element->new("path");
   $element->{"d"} = translate_path($path, $dx, $dy);
   $element->{"style"} = $style;
   $parent->addChild($element);
}

# Add leaves inside a single tile region.
sub add_leaves_in_region($$$$$$$$$)
{
   my ($dom, $region_map, $leaves,
       $tile_size_x, $tile_size_y, $tx, $ty, $scale, $frame) = @_;

   foreach my $leaf (@$leaves)
   {
      my $path = $leaf->{"d"};
      my ($x1, $y1, $x2, $y2) = get_leaf_size($path);
      if( within_leaf_region($region_map, $tx + $x1, $ty + $y1) &&
          within_leaf_region($region_map, $tx + $x2, $ty + $y2) )
      {
         my $f = get_leaf_animation_frame($frame, $tile_size_x, $tile_size_y,
                                          $x1, $y1, $x2, $y2);
         add_path($dom,
                  animate_path($path, $scale, $f),
                  $leaf->{"style"},
                  $tx, $ty);
      }
   }
}

# Add leaves to a single layer.
sub add_leaves($$$$$)
{
   my ($dom, $scale, $frame, $region_map, $leaves_template) = @_;

   my ($tile_size_x, $tile_size_y) = get_svg_size($leaves_template);
   $tile_size_x *= $scale;
   $tile_size_y *= $scale;
   my @leaves = collect_leaves_from_template($leaves_template, $scale);

   my $row = 0;
   for(my $ty = 0; $ty < HEIGHT;)
   {
      my $column = 0;
      for(my $tx = 0; $tx < WIDTH; $tx += $tile_size_x)
      {
         add_leaves_in_region($dom,
                              $region_map,
                              \@leaves,
                              $tile_size_x, $tile_size_y,
                              $tx, $ty,
                              $scale,
                              ($frame + $row + $column) & 3);
         $column++;
      }
      $row++;
      $ty += $tile_size_y;

      # Offset tile regions by half a tile horizontally at every other row.
      # This is meant to make the tile seams less obvious by making them
      # unaligned.
      $column = 0;
      for(my $tx = -$tile_size_x / 2; $tx < WIDTH; $tx += $tile_size_x)
      {
         add_leaves_in_region($dom,
                              $region_map,
                              \@leaves,
                              $tile_size_x, $tile_size_y,
                              $tx, $ty,
                              $scale,
                              ($frame + $row + $column) & 3);
         $column++;
      }
      $row++;
      $ty += $tile_size_y;
   }
}


# Load input.
if( $#ARGV != 4 )
{
   die "$0 {leaves.svg} {input.svg} {map.pgm} {scale} {frame} > {output.svg}\n";
}
my $leaves = XML::LibXML->load_xml(location => $ARGV[0]);
my $dom = XML::LibXML->load_xml(location => $ARGV[1]);
my $regions = load_region_map($ARGV[2]);
my $scale = $ARGV[3];
my $frame = $ARGV[4];
$frame =~ /^[0-3]$/ or die "Unexpected frame, expected 0..3, got $frame\n";

# Check for empty definitions in leaves template.  We can't handle these
# because it involves merging two definition sections with potentially
# conflicting IDs.  Since we currently don't use any definitions (no
# gradients, no clips, etc), we will just enforce it going forward.
foreach my $defs ($leaves->getElementsByTagName("defs"))
{
   foreach my $node ($defs->childNodes())
   {
      die "$ARGV[0] contains nonempty definitions.\n";
   }
}

# Add leaves.
add_leaves(find_layer_by_name($dom, OUTPUT_LAYER),
           $scale,
           $frame,
           $regions,
           $leaves);

# Output updated XML.
print $dom->toString(), "\n";
